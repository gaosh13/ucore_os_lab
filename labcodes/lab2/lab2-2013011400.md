## 练习题

---

### 练习0

对lab1修改的init.c、trap.c、kdebug.c与lab2相应文件采用diff命令得到补丁文件，适当修改补丁文件后再使用patch命令对lab2的文件打补丁，完成移植。

---

### 练习1

#### 设计

1. init不做修改，对于init_memmap，将n个页按照地址从小到大的顺序放入链表（双向循环）中(list_add_before(&free_list, &Page::page_link))，其中第一页property（base->property）置为连续空余页数量（n），其余页置为0，按照提示，将nr_free设为空闲页数量（n）。

1. alloc_pages中，首先对申请空间（n）检查，如果0<n<=nr_free则需要在链表中搜索合适段。空余段首的property记录的是连续空余页数量，找到第一个值大于等于n的段（le2page(le, page_link)的property），将连续的n页从链表中删除（list_del），并设置保留页标记（SetPageReserved）、清除property（ClearPageProperty）。如果原先段的长度大于n，则需要修改相应位置的property为原property-n作为剩余的段。

1. free_pages中，首先检查是否长度n>0以及页是否被申请过（PageReserved）。此后在链表的相应位置加入被释放的页。此后需要做的事情便是确定页的property，观看释放段的后面和前面是否和该段连续（Page*差为1），如果存在段连续情况，则将位于高地址的段property置为0，低地址property为合并后的段长。

#### 改进

1. 当前的程序效率是低下的，因为存储结构是链表的，所以当一个较大地址的申请可能会导致前面若干段长度不合适，或者释放空间维护链表需要找到合理的位置。以上涉及到了整个或部分链表的遍历。

1. 当前程序的链表是空闲页的链表，但申请和释放空间实际关心的部分是段的部分，实际运行程序操作系统遍历的是页而不是段，如果一
段包含了很多页则可能导致效率低下。

---

### 练习2

#### 设计

1. 需要判断所获取的第一级页表项（pgdir基址+PDX(la)偏移）是否缺失（PTE_P存在位）。

1. 如果页表项缺失且create为1则需要新建一个页，并将页的物理地址（page2pa）和3个标记位（PTE_P、PTE_W、PTE_U）组合为页表项填入页目录表。

1. 返回虚拟地址la在二级页表中的页表项（KADDR(PDE_ADDR(*pde)（获取页表物理地址）)基址+PTX(la)偏移）。

#### 页目录项（PDE）、页表（PTE）组成部分的含义、对ucore的用处

1. 页目录项由二级页表虚拟地址和标志位组成，页表项由物理地址和标志位组成。标志位分别为存在位、是否可写、数据状态（用户、内核）

1. 页目录和页表项的地址以及存在位用于完成虚拟地址到物理地址的转换，而是否可写、数据状态的标志位主要为了一些安全的考虑。

#### 页访问异常

1. 页访问异常也是一种中断，如同其它中断一样，页访问异常对应一个中断号，硬件保存现场、执行中断服务例程（涉及到状态的转换等）、恢复现场、继续执行。

1. 接下来需要分类讨论页访问异常的方式。如果因为页面在外存而导致的页缺失异常，则需要将页面从外存中读到内存中（替换掉一个页面）。替换完成后，重新执行页访问的指令，从而读到正确的页;如果因为权限问题即用户态访问内核态页面、写只读的页面导致的页缺失异常，则因为该异常不可补救，所以将会终止当前进程并产生相应的错误提示。

---

### 练习3

#### 设计

1. 检查页目录表是否存在（*ptep & PTE_P）。

1. 若存在则（pte2page）找到相应的页，若页的Page::ref为0（page_ref_dec），即页没有被引用则释放该页内存。

1. 将页目录项清空（*ptep置为0）并删除快表中的对应项（tlb_invalidate）。

#### Page全局变量每一项与页目录项和页表项的对应关系

在pmm.c的全局变量中有struct Page *pages，是一个存放了物理内存页描述的数组。

页目录表和页表采用页式存储，通过页目录表基址pgdir加偏移获取页目录项的物理地址，页目录项中存放了页表项的物理地址。

Page中一项可由page2pa函数获取其物理地址，同理有逆函数pa2page。由此可以将Page中的一项与页目录项、页表项对应。

#### 虚拟内存与物理内存相等的方案

观察pmm.h中的宏PADDR和KADDR，发现虚拟内存与物理内存的转化方式由KERNBASE作为偏移，所以需要将KERNBASE置0。

KERNBASE在memlayout.h中宏定义为0xc0000000
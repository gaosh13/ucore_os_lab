## 练习题

---

### 练习0

使用meld工具图形化界面比较lab6和lab7添加。

需要修改trap.c中关于时钟事件的处理，不再使用lab6中调度函数sched_class_proc_tick的接口（同样不使用lab5中直接对current->need_resched的修改）

---

### 练习1信号量

#### 内核级信号量

可以查看sem的c和head文件，内核信号量由变量value和等待队列wait_queue组成（包装成结构体semaphore_t），通过外部up和down间接调用了__up和__down函数，对于__up直接将value加1，若等待队列不为空则唤醒，调用wakeup_proc进入就绪队列。__down函数首先判断value是否大于0，若大于0则将其减1并返回，否则将该线程放入等待队列，设置线程状态为等待，并调用schedule调度（状态为等待，该线程不会进入就绪队列）。

由于多个线程不应同时访问和修改value，所以通过采用屏蔽中断的方式设立了临界区。

#### 用户级信号量

用户级最大的问题时临界区的设立。用户态不能使用屏蔽中断的特权函数，但可以采用软件方法、系统调用内核态对应函数或者硬件原子操作。

---

### 练习2管程

在check_sync.c中有LAB7 EXERCISE 1的部分（对应练习2），哲学家就餐的代码，可以参考信号量部分的实现。

#### 哲学家就餐设计

对于哲学家拿叉子的函数，在具有管程互斥锁的临界区，改变状态为饥饿，需要调用phi_test_condvar函数，其会判断是否左右两个哲学家是否处于就餐状态。若都不属于就餐状态，则说明叉子是可以直接获取的（因为在临界区，叉子不会被别的哲学家取走），函数中会改变状态为就餐；否则循环等待，直至自己处于就餐状态（说明当时旁边有哲学家在就餐，接下来会讲到，在旁边的哲学家就餐完毕后会唤醒该哲学家）。

对于哲学家放叉子的函数，在临界区，首先改变状态为思考（同时放下叉子），于是该哲学家提醒左右两个哲学家可能可以开始用餐（调用它们的phi_test_condvar，函数判断了就餐的基本条件，饥饿加左右两个哲学家不在用餐），联合这两个函数，就餐问题得以解决。

#### 内核级管程设计

老师在课堂上大篇幅讲解了lab7管程的设计，并布置了有关lab7_answer的作业，所以实现已经非常清楚。

在ucore_lab7中，管程基于信号量实现，使用了up和down函数，实现Hoare机制。所以用到了信号量mutex，next、变量next_count和一系列条件变量，在条件变量中有sem的信号量和count变量。关于Hoare机制的具体实现细节分析如下：

1. 在wait函数中，则关闭互斥所，并使用down该条件的信号量等待调用对应条件的signal函数（还有一些细节接下来会谈到）。

1. 在signal函数中，如果该条件中存在等待的线程（count大于0），则up该条件的信号量试图唤醒一个等待线程（仅加入就绪队列），而自己则在相应管程中down信号量next，该线程阻塞，于是起到了立刻唤醒线程的效果，next_count表示因此阻塞的线程数，只可能是0或1。

1. 发出signal的线程由于被阻塞了，应当在适当的时候由唤醒，具体说来是关闭互斥锁的时候释放。一种情形是管程中执行完毕的检查，用户实现（不是操作系统）判断是否有在signal中阻塞的线程（next_count为1）。如果存在则试图唤醒它（up管程的信号量next，加入就绪队列），且不打开锁（相当于锁的转交），所以其它线程并不能进入，临界区在接下来会由线程a使用；如果不存在则正常释放互斥所，这意味着在管程中没有正在执行的程序。另一种情形是再一次调用wait时，在count加1后操作系统（不是用户）立刻进行同用户管程结束时一样的判断，如果有阻塞的线程（发出signal）则将其唤醒，否则关闭互斥锁等待新的线程进入管程。

#### 用户级管程设计

用户级管程设计与用户级信号量设计面临着同样的互斥锁问题。

此外，用户级管程可以通过调用用户级或内核级信号量实现。
